<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" width="95%" height="95%"
	creationComplete="onCreationComplete()">
    <mx:Script source="Activity3DChartAction.as" />
	<mx:Script>
		<![CDATA[
		import models.events.HoneypotEventMessage;
		import models.graphs.Activity3DChartNode;
		import models.graphs.ActivityTimeDict;
		import org.papervision3d.render.BasicRenderEngine;
		import org.papervision3d.materials.utils.MaterialsList;
		import org.papervision3d.materials.special.CompositeMaterial;
		import org.papervision3d.scenes.*;
		import org.papervision3d.objects.*;
		import org.papervision3d.objects.primitives.*;
		import org.papervision3d.cameras.*;
		import org.papervision3d.materials.*;
		import org.papervision3d.view.Viewport3D;
		import org.papervision3d.events.InteractiveScene3DEvent;
		import org.papervision3d.scenes.Scene3D;
		import mx.core.UIComponent;
		import controllers.ActivityChartManager;
		import models.utils.Logger;

		import mx.charts.series.LineSeries;
		import mx.collections.ArrayCollection;


		private var container : UIComponent;
		private var viewport : Viewport3D;
		private var scene : Scene3D;
		private var camera : Camera3D;
		private var rootNode : DisplayObject3D;
		private var renderer:BasicRenderEngine;
		
		private var startX : Number = 0;
		private var startY : Number = 0;
		
		private var maxZoom : Number = 100;
		private var minZoom : Number = 0.1;
		
		private var axisLength : Number = 150;
			
 		private var floor:Plane;
 		private var basicMaterial:MaterialsList;

		private var timeWall:Plane;
		private var timeWallWidth:Number = 500;
		private var timeWallHeight:Number = 100;
		private var timeMulNum:Number;
		private var lastTimeWallMoved:Number;
		private var timeWallPeriod:Number = 1000;
		
		private var activityPeriod:Number = 10000;// milliseconds
		

		private function onCreationComplete():void
		{
			container = canvas;
			init3D();

			addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
			addEventListener(MouseEvent.MOUSE_UP,   onMouseUp);
			addEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel);
		}

		private function initTimeWall():void
		{
			var coMaterial1:ColorMaterial = new ColorMaterial(0xFF9999, 0.3);
			var timeWallMaterial:CompositeMaterial = new CompositeMaterial();
			timeWallMaterial.addMaterial(coMaterial1);
			timeWallMaterial.doubleSided = true;

			timeWall = new Plane(timeWallMaterial, timeWallWidth, timeWallHeight);
			rootNode.addChild(timeWall);
			timeWall.y = 0;
			timeWall.x = timeWallWidth/2;
			timeWall.z = timeWallHeight/2;
			timeWall.rotationX = 90;
			lastTimeWallMoved = 0;
		}		
		
		private function moveTimeWall(time:Number):void
		{
			timeWall.y = time / 100;
			render();
		}
		
		public var count:uint = 0;
		public function seekByTime(time:Number):void
		{
			if (time < lastTimeWallMoved) {
				lastTimeWallMoved = uint(time / timeWallPeriod) * timeWallPeriod;
				return;
			}
			if (time >= lastTimeWallMoved + timeWallPeriod) {
				moveTimeWall(time);
				lastTimeWallMoved = time;
			}
		}
		
		/*
			Quioted http://blog.livedoor.jp/takaaki_bb/archives/50614075.html
		*/
		private function init3D():void
		{
			var c:UIComponent = new UIComponent;
			container.addChild(c);
			c.width = container.width;
			c.height = container.height;

			viewport = new Viewport3D(c.width, c.height, true, true);
			c.addChild(viewport);

			scene = new Scene3D();
			
			
			renderer = new BasicRenderEngine();
			
			
			/*
				Camera configuration
			*/
			camera = new Camera3D;

			camera.x = 500;
			camera.y = 500;
			camera.z = 500;
			
			
			camera.focus = 1000;
			camera.zoom = 50;

			
			rootNode = scene.addChild(new DisplayObject3D("rootNode"));
			var xAxis:DisplayObject3D = drawAxis(0xFF0000);
			xAxis.yaw(90);
			var yAxis:DisplayObject3D = drawAxis(0x00FF00);
			yAxis.pitch(-90);
			var zAxis:DisplayObject3D = drawAxis(0x0000FF);
			
			var color:uint = 0xFFFF00;
			var colorMaterial:ColorMaterial = new ColorMaterial(color, 1);
			var wireMaterial:WireframeMaterial = new WireframeMaterial(color);
			
			var compoMaterial:CompositeMaterial = new CompositeMaterial();
			compoMaterial.addMaterial(wireMaterial);
			compoMaterial.doubleSided = true;
			
			var materialsList:MaterialsList = new MaterialsList();
			basicMaterial = materialsList;
			materialsList.addMaterial(compoMaterial, "all");
			
			var cube1:Cube = new Cube(materialsList, 20, 20, 20);
			cube1.z = 50;
			
			rootNode.addChild(xAxis);
			rootNode.addChild(yAxis);
			rootNode.addChild(zAxis);
			rootNode.addChild(cube1);
			
			rootNode.rotationX = -90;
			rootNode.rotationY = 90;
			rootNode.rotationZ = 2;
			
			rootNode.x = 250;
			rootNode.y = 0;
			
			camera.lookAt(cube1);
			drawFloor(500, 500);
			initTimeWall();
			render();
 		}
 		
 		public function drawFloor(width:Number, height:Number):void
 		{
			var coMaterial1:ColorMaterial = new ColorMaterial(0xDDDDDD);

			var floorMaterial:CompositeMaterial = new CompositeMaterial();
			floorMaterial.addMaterial(coMaterial1);
			floorMaterial.doubleSided = true;

			floor = new Plane(floorMaterial, width, height);
			rootNode.removeChild(floor);
			rootNode.addChild(floor);
			floor.rotationZ = 180;
			floor.y = height / 2;
			floor.x = width / 2;
 			
 		} 
 		
 		/*
 			Gets honeypotEventMessages and draws
 		*/
 		public function initGraph(messages:Array):void
 		{
 			var timeDict:ActivityTimeDict;
 			var msg:HoneypotEventMessage;
 			var hostNames:Array = new Array;
 			for each(msg in messages) {
 				hostNames.push(msg.hostname ? msg.hostname : msg.host1);
 			}
 			prepareNodeIndex(hostNames);
 			/*
 				time => array of Activity3DChartnode
 			*/
 			
 			
 			timeDict = processHoneypotMessages(messages, activityPeriod);
 			var a:Array;
 			var t:Number;
 			var timeArray:Array = timeDict.keys();
 			for each(t in timeArray) {
 				a = timeDict.getMessagesByTime(t);
 				drawNodesByTime(t, a);
 			}
 			
 			render();
            
 		}
 		
 		
 		private function drawNodesByTime(time:Number, nodes:Array):void {
 			var n:Activity3DChartNode;
 			for each (n in nodes) {
 				drawNodeByTime(time, n);
 			}
 		}
 		
 		private var _nodeNameIndexDict:Object = new Object;
 		private function prepareNodeIndex(nodeNames:Array):void {
 			var nodeName:String;
 			var i:int = 0;
 			for each(nodeName in nodeNames) {
 				if (_nodeNameIndexDict[nodeName] == null) {
 					_nodeNameIndexDict[nodeName] = i;
 					i++;
 				}
 			}
 		}
 		
 		private function getNodeIndex(nodeName:String):int {
 			var i:int;
 			if (_nodeNameIndexDict[nodeName] == null) {
 				Logger.log("No such node index");
 				return -1;
 			}
 			return _nodeNameIndexDict[nodeName];
 		}
 		
 		/*
 			Draws a node
 		*/
 		private function drawNodeByTime(time:Number, node:Activity3DChartNode):void
 		{
			var cube:Cube = new Cube(basicMaterial, 20, node.activity * 10, 20);
 			cube.x = getNodeIndex(node.hostName) * 25;
 			cube.y = time / 100;
 			cube.z = node.activity * 5;
 			rootNode.addChild(cube);
 		}
 		
 		private function onMouseDown(event:MouseEvent):void {
            startX = event.stageX;
            startY = event.stageY;
            addEventListener(MouseEvent.MOUSE_MOVE, onMouseMove); 		
 		}
		private function onMouseMove(event:MouseEvent):void {
            // 順番気にせず回転させる場合
            rootNode.yaw(- (event.stageX - startX));
            rootNode.pitch(event.stageY - startY);
            
            // 順番に回転させる場合
            //rootNode.rotationZ -= (event.stageY - startY);
            //rootNode.rotationY -= (event.stageX - startX);
            
            // 直感的に(画面上のx軸、y軸に沿って)回転させる方法はどうやるんだろう
            
            startX = event.stageX;
            startY = event.stageY;
            
            // レンダリングしなおす
            render();
        }
        
        private function render():void
        {
        	//レンダリング
            renderer.renderScene(scene, camera, viewport);
        }

		private function onMouseWheel(e:MouseEvent):void
		{
			if ((camera.zoom <= maxZoom && camera.zoom >= minZoom)
				|| (camera.zoom >= maxZoom && e.delta < 0)
				|| (camera.zoom <= minZoom && e.delta > 0)) {
				camera.zoom += e.delta / 2;
			}
			if (camera.zoom < 1) { 
				camera.zoom = 1;
			}
			render();
		}
		private function onMouseUp(event:MouseEvent):void {
            removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);
        }
		private function drawAxis(color:uint, length:Number = -1):DisplayObject3D {
            // 色設定
            if (length < 0) length = axisLength;
            var colorMaterial:ColorMaterial = new ColorMaterial(color, 1);
            var wireMaterial:WireframeMaterial = new WireframeMaterial(color);
            
            var compoMaterial:CompositeMaterial = new CompositeMaterial();
            compoMaterial.addMaterial(colorMaterial);
            // compoMaterial.addMaterial(wireMaterial);
            compoMaterial.doubleSided = true;
            compoMaterial.interactive = true;
            
            var materialsList:MaterialsList = new MaterialsList();
            materialsList.addMaterial(compoMaterial, "all");
            // 線を引く (円柱だけど)
            var axis:DisplayObject3D = new Cylinder(compoMaterial, 2, length);
            axis.z = 75;
            axis.rotationX = 90;
            
            // 矢印の先を描く (球だけど)
            var sphere:DisplayObject3D = new Sphere(compoMaterial, 10);
            sphere.z = length;
            
            sphere.addEventListener(InteractiveScene3DEvent.OBJECT_CLICK, function ():void{
            	trace("clicked");
            });
            
            var node:DisplayObject3D = new DisplayObject3D();
            node.addChild(axis);
            node.addChild(sphere);
            
            return node;
        }
		]]>
	</mx:Script>
	<mx:Panel title="Activity Line Chart"  width="100%" height="95%" >
		<mx:VBox width="100%" height="100%" >
			<!-- <mx:CheckBox id="drawGraphCheck" label="Draw Graph" selected="{_drawGraph}"
				click="toggleDraw()" /> -->
			<mx:Canvas id="canvas" width="100%" height="100%" backgroundColor="0x000000" />		
		</mx:VBox>
	</mx:Panel>	
</mx:Canvas>
